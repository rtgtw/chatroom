<div align="center" style="text-align: center;">
 <img src="./frontend/public/chatroom.png" alt="example" width="2000"/>
 </div>
 

 # WebSocket Chatroom Implementation Overview

## Recap
This document covers:
- **Why I decided to build this project**
- **What I learned during the process**
- **The technical implementation of the WebSocket Chatroom**

---

## Why I Decided to Build This Project

This project began with my curiosity about APIs. While working on a Netflix clone and building backend REST API endpoints, I realized that RESTful APIs are stateless—they don’t retain information about clients between requests. This sparked my interest in stateful protocols, which maintain a persistent connection and remember client information.

That’s when I discovered WebSockets, a stateful protocol that keeps a TCP connection alive. I wanted to dive deeper into how WebSockets work and decided to build this chatroom to explore its implementation and use cases.

---

## What I Learned During the Process

I learned an incredible amount while building this project:
- **Understanding the OSI Model**: I explored the layers of communication protocols and the differences between stateful and stateless architectures.
- **WebSocket Fundamentals**: I gained hands-on experience with receiving WebSocket connections, handling inbound data, logging activity, and sending responses.
- **Frontend and Backend Integration**: I hosted both frontend and backend servers, which helped me understand the flow of data between the server and the client.
- **Static HTML and Dynamic UI**: I created a simple static HTML interface to represent the client and implemented features that allowed users to interact with the chatroom.
- **Error Handling**: I encountered and resolved various errors, from server-side exceptions to frontend UI issues, strengthening my debugging skills.

---

## The Technical Implementation of the WebSocket Chatroom

### Backend Implementation
- **Technology Stack**: 
  - Built using JavaScript.
  - Utilized Node.js's native `http` library to create an HTTP server.
  - Used the `ws` WebSocket library to handle inbound WebSocket connections.

- **Room Management**:
  - Created a `rooms` map where each room name was a key, and the value was a `Set` of connected WebSocket clients.
  - This allowed dynamic creation of rooms and efficient client management.

- **Client Identification**:
  - Developed a `generateUniqueId` function to assign each client a unique ID. This function ensured no duplicate IDs were generated by checking against existing IDs.

- **Event Handling**:
  - Used the WebSocket library’s `.on()` method to handle events such as:
    - **`message`**: Processed incoming client messages to:
      - Add clients to rooms when they typed "JOIN ROOM".
      - Facilitate private 1:1 chats.
    - **`close`**: Handled client disconnections and cleaned up resources.
    - **`error`**: Managed errors to ensure the server remained stable.

### Frontend Implementation
- **WebSocket Connection**:
  - Created a WebSocket connection on the frontend to communicate with the backend server.
  - Listened for server events to update the UI dynamically.

- **UI Interaction**:
  - Connected JavaScript variables to an HTML document to enable user interaction.
  - Built a simple `index.html` file where users could join rooms, send messages, and interact with the chatroom.

- **Frontend-Backend Integration**:
  - Used Express.js to serve the static frontend files (`index.html` and `clientv2.js`) to the client.
  - Express.js also handled hosting for the frontend server.

---
 
## Conclusion

This project was a rewarding experience that deepened my understanding of WebSockets, client-server communication, and the intricacies of stateful protocols. It also honed my skills in designing both backend and frontend systems while exploring real-world use cases for WebSockets. The result is a fully functional WebSocket-based chatroom with room management, private chats, and a user-friendly interface.
